# Any copyright is dedicated to the Public Domain.
# https://creativecommons.org/publicdomain/zero/1.0/

#OR

# This Source Code Form is subject to the terms of the Mozilla Public
# License, v. 2.0. If a copy of the MPL was not distributed with this
# file, You can obtain one at https://mozilla.org/MPL/2.0/.

"""Обратимая транслитерация русский-латинский"""

"""Обеспечивает однозначное соответствие исходных одиночных символов и конечных мультиграфем
с сохранением приемлемой человекочитаемости.
Сохраняет регистры символов.

Однозначное соответствие обеспечивается простым правилом: 
мультиграфема создается комбинированием строго одного значащего символа
и специальных символов (см. ниже исключение).
Специальный символ не имеет собственного значения.
В итоге, ни одна мультиграфема не состоит из комбинации символов, 
каждый из которых может быть преобразован по отдельности
(например, 
недопустимо представление Ц как TS,
либо использование символа Hh и как самостоятельного обозначения (для Х, например), и как специального символа)

Отдельный специальный символ расположен всегда строго перед или строго после основного значащего символа,
что обеспечит удобство посимвольной обработки в один проход (при необходимости)

"""

RULES = {
    # порядок элементов важен для корректной обработки (при обратном перобразовании),
    # ЕСЛИ использовать _silly варианты замены

    # спецсимволы:
    # H конечный
    # J начальный
    # вместо J можно использовать Y, в этом случае нужно обменять его с символом для Й 
    

    'Щ' : 'SHH' # "модификация" Ш SH
    
    # йотированные "гласные буквы" (sic)
    ,'Ё' : 'JO'
    ,'Ю' : 'JU'
    ,'Я' : 'JA'

    # в английском стиле
    ,'Ж' : 'ZH'
    ,'Х' : 'KH'
    ,'Ч' : 'CH'
    ,'Ш' : 'SH'

    # "контр-йотированные" буквы
    ,'Ы' : 'IH'
    ,'Э' : 'EH'

    # неочевидная логика:
    # в древности это были краткие гласные:
    ,'Ъ' : 'JY' # этот (безударный О/А) - не смягчал предыдущую согласную, поэтому здесь изображено что-то вроде сурового удвоенного ЙЙ
    ,'Ь' : 'JH' # этот (очень короткое И) смягчал, поэтому его Й (символизирующий краткость) ослабляем немым H
        
    ,'А' : 'A'
    ,'Б' : 'B'
    ,'В' : 'V'
    ,'Г' : 'G'
    ,'Д' : 'D'
    ,'Е' : 'E'
    ,'З' : 'Z'
    ,'И' : 'I'
    ,'Й' : 'Y' # Й здесь
    ,'К' : 'K'
    ,'Л' : 'L'
    ,'М' : 'M'
    ,'Н' : 'N'
    ,'О' : 'O'
    ,'П' : 'P'
    ,'Р' : 'R'
    ,'С' : 'S'
    ,'Т' : 'T'
    ,'У' : 'U'
    ,'Ф' : 'F'
    ,'Ц' : 'C'

    # для украинского и белорусского алфавитов могут быть такие варианты:
    # Г, Ґ как GH,  G; Ї как JI, Є как JE
    # Ў как UH (У краткая)
}

MULTS = []
for key in RULES:
    if len(RULES[key]) > 1:
        MULTS.append(key.upper())

def variations(inStr, pref = '', outList = None):
    """все возможные комбинации регистров"""

    """Рекурсия. 2^len(inStr)"""
    if outList == None:
        outList = []
    if inStr == '':
        # если символ не имеет разных регистров - будет дубль. 
        # Это не страшно, а вот проверка утяжелит обработку
        outList.append(pref)
        return
    for el in inStr[0].lower(), inStr[0].upper():
        variations(inStr[1:], pref + el, outList)
    return outList

def pairs(inSymb, parentKey):
    outList = [] # порядок важен: сначала пары символов, затем одиночный
    if inSymb == inSymb.upper():
        if inSymb in MULTS:
            #если потенциальная мультиграфема
            for key in RULES:
                # пара Наш Заглавный плюс следующий строчный
                # заменится на наш капитализированный плюс следующий строчный
                outList.append((inSymb + key.lower(), RULES[parentKey].capitalize() + RULES[key].lower()))
        # добавляем одиночный заглавный символ
        # - в итоге в конце обработки всех пар в целевой строке Нащ Заглавный останется строго
        # либо в конечной позиции слова
        # либо стоящим перед другими заглавными 
        # а это замена на полностью заглавный
        outList.append((inSymb, RULES[parentKey].upper()))
    else:
        # нижний регистр проверки не требует - меняется на строчный же
        outList.append((inSymb, RULES[parentKey].lower()))
    return outList


def trans_to(inStr):
    """русский в транслит"""
    outStr = inStr
    for key in RULES:
        for var in variations(key):
            # для правильного определения верхнего регистра нужно символ,
            # если вдруг он соответствует мультиграфеме,
            # обработать парами вместе со следующим символом
            for pair in pairs(var, key):
                outStr = outStr.replace(pair[0], pair[1])
    return outStr

def trans_from(inStr):
    """транслит в русский (обратная замена)"""
    outStr = inStr
    for key in RULES:
        repl = RULES[key]
        # не исключаем ситуацию, что регистр символов в мультиграфеме не соблюден,
        # оппределяем все варианты
        for var in variations(repl):
            if (
                var == var.upper()
                or var == var.capitalize()
            ):
                # про заглавность исходного символа можно судить только если
                # строго все его символы заглавные
                # либо заглавный только первый символ
                # - это предполагает разумный замысел при его первоначальном создании
                # остальное - сКОрЕе вСеГо мУСоР
                repl = key.upper()
            else:
                repl = key.lower()

            outStr = outStr.replace(var, repl)
    return outStr


def silly_trans_to(inStr):
    """Если не нужна красивость преобразования верхнего регистра - то работает быстрее"""

    """Если заранее подготовить словарь с обоими регистрами, то можно сэкономить на upper/lower"""

    outStr = inStr
    for key in RULES:
        outStr = outStr.replace(key.upper(), RULES[key].upper())
        outStr = outStr.replace(key.lower(), RULES[key].lower())
    return outStr

def silly_trans_from(inStr):
    """Если в строке НЕ сохранился исходный регистр - то пропустит разнорегистровые мультиграфемы"""
    outStr = inStr
    for key in RULES:
        outStr = outStr.replace(RULES[key].upper(), key.upper())
        outStr = outStr.replace(RULES[key].lower(), key.lower())
    return outStr